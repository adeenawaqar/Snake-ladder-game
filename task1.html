<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Snake & Ladder</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');
  
  * { box-sizing: border-box; }

  body {
    margin: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family: 'Poppins', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    color: #333;
    padding: 20px;
  }

  header {
    margin-bottom: 25px;
    font-size: 3rem;
    font-weight: 800;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 0 4px 10px rgba(0,0,0,0.3);
  }

  #game-container {
    display: flex;
    flex-wrap: wrap;
    max-width: 850px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.3);
    overflow: hidden;
    padding: 10px;
    border: 1px solid rgba(255,255,255,0.5);
  }

  #board {
    width: 500px;
    height: 500px;
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
    position: relative;
    background: #fff;
    border-radius: 12px;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
    overflow: hidden;
  }

  .cell {
    border: 1px solid rgba(0,0,0,0.05);
    position: relative;
    font-size: 0.75rem;
    display: flex;
    justify-content: flex-end;
    align-items: flex-start;
    padding: 4px 6px 0 0;
    color: #555;
    font-weight: 600;
  }

  .cell:nth-child(odd) { background-color: #e3f2fd; } 
  .cell:nth-child(even) { background-color: #ffffff; } 

  .snake {
    position: absolute;
    stroke: #ff4081; 
    stroke-width: 6;
    stroke-linecap: round;
    fill: none;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.2));
  }
  
  .ladder {
    position: absolute;
    stroke: #ff9800; 
    stroke-width: 6;
    stroke-linecap: round;
    fill: none;
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.2));
  }

  .snake-head, .snake-tail {
    fill: #d81b60;
    stroke: #fff;
    stroke-width: 2;
  }

  .ladder-rung {
    stroke: #ff9800;
    stroke-width: 4;
  }

  #info-panel {
    flex: 1;
    min-width: 280px;
    padding: 25px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  #players-info {
    margin-bottom: 30px;
    background: #fff;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
  }

  .player {
    margin-bottom: 10px;
    font-weight: 600;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    padding: 8px;
    border-radius: 8px;
  }

  .player-color {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    margin-right: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    border: 2px solid #fff;
  }
  
  .player1-color { background: #ff5252; }
  .player2-color { background: #448aff; }

  #dice-container {
    text-align: center;
    background: #fff;
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    margin-bottom: 20px;
  }

  #dice {
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    background: #f5f5f5;
    border-radius: 18px;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.1);
    font-size: 3rem;
    line-height: 80px;
    font-weight: 800;
    color: #333;
    border: 1px solid #ddd;
  }

  button {
    border: none;
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
    font-size: 1rem;
    padding: 12px 30px;
    border-radius: 50px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    text-transform: uppercase;
    letter-spacing: 1px;
    width: 100%;
  }

  #roll-btn {
    background: linear-gradient(45deg, #11998e, #38ef7d);
    color: white;
    box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
  }

  #roll-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(56, 239, 125, 0.5);
  }

  #roll-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
  }

  #reset-btn {
    background: linear-gradient(45deg, #ff416c, #ff4b2b);
    color: white;
    box-shadow: 0 5px 15px rgba(255, 75, 43, 0.4);
    margin-top: 10px;
  }

  #reset-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(255, 75, 43, 0.5);
  }

  #message {
    margin-top: 15px;
    font-size: 1rem;
    min-height: 3em;
    font-weight: 600;
    color: #444;
    line-height: 1.4;
  }

  .token {
    position: absolute;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 3px solid #fff;
    box-shadow: 0 3px 8px rgba(0,0,0,0.4);
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    z-index: 100;
  }
  .token.player1 { background: #ff5252; }
  .token.player2 { background: #448aff; }

  @media (max-width: 900px) {
    header { font-size: 2rem; }
    #game-container {
      flex-direction: column;
      max-width: 500px;
      align-items: center;
    }
    #board {
      width: 100vw;
      height: 100vw;
      max-width: 450px;
      max-height: 450px;
    }
    #info-panel {
      width: 100%;
      padding: 20px;
    }
    .player { font-size: 1rem; }
  }
</style>
</head>
<body>
<header>Snake & Ladder</header>
<div id="game-container">
  <div id="board"></div>
  <div id="info-panel">
    <div id="players-info">
      <div class="player" id="player1-info">
        <div class="player-color player1-color"></div>
        <div style="flex:1">
            <span style="display:block; font-size:0.8rem; color:#888;">PLAYER 1</span>
            <span id="player1-pos" style="color:#333; font-size:1.2rem;">Start</span>
        </div>
      </div>
      <div class="player" id="player2-info">
        <div class="player-color player2-color"></div>
        <div style="flex:1">
            <span style="display:block; font-size:0.8rem; color:#888;">PLAYER 2</span>
            <span id="player2-pos" style="color:#333; font-size:1.2rem;">Start</span>
        </div>
      </div>
    </div>

    <div id="dice-container">
      <div id="dice">-</div>
      <button id="roll-btn">ROLL DICE</button>
      <div id="message">Player 1 starts.</div>
    </div>
    <button id="reset-btn">RESET GAME</button>
  </div>
</div>

<script>
(() => {
  const board = document.getElementById('board');
  const rollBtn = document.getElementById('roll-btn');
  const dice = document.getElementById('dice');
  const message = document.getElementById('message');
  const player1PosSpan = document.getElementById('player1-pos');
  const player2PosSpan = document.getElementById('player2-pos');

  const BOARD_SIZE = 100;
  const snakes = { 16: 6, 48: 26, 49: 11, 56: 53, 62: 19, 64: 60, 87: 24, 93: 73, 95: 75, 98: 78 };
  const ladders = { 1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 36: 44, 51: 67, 71: 91, 80: 100 };

  const players = [
    { id: 1, name: 'Player 1', colorClass: 'player1', position: 0 },
    { id: 2, name: 'Player 2', colorClass: 'player2', position: 0 }
  ];
  let currentPlayerIndex = 0;
  let gameOver = false;
  const tokens = {}; 

  function createBoard() {
    board.innerHTML = '';
    for (let row = 9; row >= 0; row--) {
      for (let col = 0; col < 10; col++) {
        let cellNum = row % 2 === 0 ? (row * 10 + col + 1) : (row * 10 + (9 - col) + 1);
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.cell = cellNum;
        cell.innerHTML = `<span>${cellNum}</span>`;
        board.appendChild(cell);
      }
    }
  }

  function getCellCoordinates(cellNum) {
    const zeroIndex = cellNum - 1;
    const row = Math.floor(zeroIndex / 10);
    const col = row % 2 === 0 ? zeroIndex % 10 : 9 - (zeroIndex % 10);
    const cellSize = board.clientWidth / 10;
    return {
      x: col * cellSize + cellSize / 2, 
      y: (9 - row) * cellSize + cellSize / 2 
    };
  }

  let svgOverlay;
  function createSVGOverlay() {
    if (svgOverlay) svgOverlay.remove();
    svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgOverlay.setAttribute('width', board.clientWidth);
    svgOverlay.setAttribute('height', board.clientHeight);
    svgOverlay.style.position = 'absolute';
    svgOverlay.style.top = 0;
    svgOverlay.style.left = 0;
    svgOverlay.style.pointerEvents = 'none'; 
    svgOverlay.style.zIndex = 10; 
    board.appendChild(svgOverlay);
  }
  
  function drawPath(startCell, endCell, type) {
    const start = getCellCoordinates(startCell);
    const end = getCellCoordinates(endCell);
    
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const curveFactor = 0.3;
    const cx1 = start.x + dx * curveFactor;
    const cy1 = start.y - dy * curveFactor;
    const cx2 = end.x - dx * curveFactor;
    const cy2 = end.y + dy * curveFactor;

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = `M${start.x},${start.y} C${cx1},${cy1} ${cx2},${cy2} ${end.x},${end.y}`;
    path.setAttribute('d', d);
    path.setAttribute('class', type);
    svgOverlay.appendChild(path);

    // This part handles drawing visual elements (snake head/ladder rungs) along the path
    function bezierPoint(p0, p1, p2, p3, t) {
      const cX = 3 * (p1 - p0);
      const bX = 3 * (p2 - p1) - cX;
      const aX = p3 - p0 - cX - bX;
      return aX * t * t * t + bX * t * t + cX * t + p0;
    }

    if (type === 'snake') {
      const head = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      head.setAttribute('cx', start.x);
      head.setAttribute('cy', start.y);
      head.setAttribute('r', 5);
      head.setAttribute('class', 'snake-head');
      svgOverlay.appendChild(head);
    } else if (type === 'ladder') {
      const steps = 6;
      for(let i=1; i<steps; i++) {
        const t = i/steps;
        const tx = bezierPoint(start.x, cx1, cx2, end.x, t);
        const ty = bezierPoint(start.y, cy1, cy2, end.y, t);
        
        const rung = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        rung.setAttribute('x1', tx - 6);
        rung.setAttribute('y1', ty);
        rung.setAttribute('x2', tx + 6);
        rung.setAttribute('y2', ty);
        rung.setAttribute('class', 'ladder-rung');
        svgOverlay.appendChild(rung);
      }
    }
  }

  function drawSnakesAndLadders() {
    createSVGOverlay();
    for (const [start, end] of Object.entries(ladders)) { drawPath(parseInt(start), end, 'ladder'); }
    for (const [start, end] of Object.entries(snakes)) { drawPath(parseInt(start), end, 'snake'); }
  }

  function createTokens() {
    players.forEach(p => {
      const token = document.createElement('div');
      token.classList.add('token', p.colorClass);
      board.appendChild(token);
      tokens[p.id] = token;
    });
  }

  function updateTokens() {
    const cellSize = board.clientWidth / 10;
    players.forEach(p => {
      const token = tokens[p.id];
      if (p.position === 0) {
        token.style.transform = `translate(${cellSize/2 - 12}px, ${board.clientHeight + 10}px)`;
        token.style.opacity = 0;
      } else {
        const coords = getCellCoordinates(p.position);
        const offsetX = p.id === 1 ? -6 : 6; 
        const offsetY = p.id === 1 ? -6 : 6;
        token.style.transform = `translate(${coords.x + offsetX - 12}px, ${coords.y + offsetY - 12}px)`;
        token.style.opacity = 1;
      }
    });
  }

  function updatePlayersInfo() {
    players.forEach(p => {
      const posSpan = p.id === 1 ? player1PosSpan : player2PosSpan;
      posSpan.textContent = p.position === 0 ? 'Start' : (p.position === 100 ? 'WINNER!' : 'Tile ' + p.position);
    });
  }

  function rollDice() {
    if (gameOver) return;
    rollBtn.disabled = true; 
    message.textContent = `${players[currentPlayerIndex].name} rolling...`;
    
    let rolls = 10; 
    const interval = setInterval(() => {
      const tempRoll = Math.floor(Math.random() * 6) + 1;
      dice.textContent = tempRoll; 
      dice.style.transform = `rotate(${Math.random()*20 - 10}deg) scale(1.1)`; 
      rolls--;
      if (rolls <= 0) {
        clearInterval(interval);
        dice.style.transform = `rotate(0deg) scale(1)`;
        processMove(tempRoll); 
      }
    }, 80);
  }

  function processMove(roll) {
    const player = players[currentPlayerIndex];
    let newPos = player.position + roll;
    
    setTimeout(() => {
      if (newPos > BOARD_SIZE) {
        message.textContent = `Rolled ${roll}. Too high to finish!`;
      } else {
        message.textContent = `${player.name} moved to ${newPos}.`;
        
        let finalPos = newPos;
        let actionMsg = "";
        
        if (ladders[newPos]) {
            finalPos = ladders[newPos];
            actionMsg = " UP THE LADDER! ðŸš€";
        } 
        else if (snakes[newPos]) {
            finalPos = snakes[newPos];
            actionMsg = " OOPS! SNAKE BITE! ðŸ";
        }

        player.position = finalPos; 
        message.textContent += actionMsg;
      }
        
      updateTokens();
      updatePlayersInfo();

      if (player.position === BOARD_SIZE) {
        message.textContent = `ðŸŽ‰ ${player.name} WINS THE GAME! ðŸŽ‰`;
        message.style.color = "#d81b60";
        gameOver = true;
        rollBtn.disabled = true;
        return;
      }

      if (roll === 6 && !gameOver) {
        message.textContent += ` Rolled 6! Roll again.`;
        rollBtn.disabled = false;
      } else {
        currentPlayerIndex = (currentPlayerIndex + 1) % players.length; 
        message.textContent = `${player.name}'s move completed. Now ${players[currentPlayerIndex].name}'s turn.`;
        rollBtn.disabled = false;
      }
    }, 500); 
  }

  function resetGame() {
    players.forEach(p => p.position = 0);
    currentPlayerIndex = 0;
    gameOver = false;
    dice.textContent = '-';
    message.textContent = `New Game! Player 1 starts.`;
    message.style.color = "#444";
    updateTokens();
    updatePlayersInfo();
    rollBtn.disabled = false;
  }

  function init() {
    createBoard();
    setTimeout(() => {
      drawSnakesAndLadders();
      createTokens();
      updateTokens();
    }, 100);
  }

  rollBtn.addEventListener('click', rollDice);
  document.getElementById('reset-btn').addEventListener('click', resetGame);
  window.addEventListener('resize', () => { board.innerHTML = ''; init(); }); 

  init();
})();
</script>
</body>
</html>
